// Copyright (C) 2nilfmt.Errorf("a")4-2nilfmt.Errorf("a")8 Goodrain Co., Ltd.
// RAINBOND, Application Management Platform

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version. For any non-GPL usage of Rainbond,
// one or multiple Commercial Licenses authorized by Goodrain Co., Ltd.
// must be obtained first.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

package gc

import (
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/Sirupsen/logrus"
	eventutil "github.com/goodrain/rainbond/eventlog/util"
	"github.com/goodrain/rainbond/worker/discover/model"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// GarbageCollector -
type GarbageCollector struct {
	clientset kubernetes.Interface
}

// NewGarbageCollector -
func NewGarbageCollector(clientset kubernetes.Interface) *GarbageCollector {
	gcr := &GarbageCollector{
		clientset: clientset,
	}
	return gcr
}

// DelLogFile deletes persistent data related to the service based on serviceID.
func (g *GarbageCollector) DelLogFile(serviceGCReq model.ServiceGCTaskBody) {
	logrus.Infof("service id: %s; delete log file.", serviceGCReq.ServiceID)
	// log generated during service running
	logPath := "/grdata/logs"
	dockerLogPath := eventutil.DockerLogFilePath(logPath, serviceGCReq.ServiceID)
	if err := os.RemoveAll(dockerLogPath); err != nil {
		logrus.Warningf("remove docker log files: %v", err)
	}
	// log generated by the service event
	eventLogPath := eventutil.EventLogFilePath(logPath)
	for _, eventID := range serviceGCReq.EventIDs {
		eventLogFileName := eventutil.EventLogFileName(eventLogPath, eventID)
		logrus.Debugf("remove event log file: %s", eventLogFileName)
		if err := os.RemoveAll(eventLogFileName); err != nil {
			logrus.Warningf("file: %s; remove event log file: %v", eventLogFileName, err)
		}
	}
}

// DelVolumeData -
func (g *GarbageCollector) DelVolumeData(serviceGCReq model.ServiceGCTaskBody) {
	f := func(prefix string) {
		dir := path.Join(prefix, fmt.Sprintf("tenant/%s/service/%s", serviceGCReq.TenantID, serviceGCReq.ServiceID))
		logrus.Infof("volume data. delete %s", dir)
		if err := os.RemoveAll(dir); err != nil {
			logrus.Warningf("dir: %s; remove volume data: %v", dir, err)
		}
	}
	f("/grdata")
	f("/grlocaldata")
}

// DelPvPvcByServiceID -
func (g *GarbageCollector) DelPvPvcByServiceID(serviceGCReq model.ServiceGCTaskBody) {
	logrus.Infof("service_id: %s", serviceGCReq.ServiceID)
	deleteOpts := &metav1.DeleteOptions{}
	listOpts := metav1.ListOptions{
		LabelSelector: fmt.Sprintf("service_id=%s", serviceGCReq.ServiceID),
	}
	if err := g.clientset.CoreV1().PersistentVolumes().DeleteCollection(deleteOpts, listOpts); err != nil {
		logrus.Warningf("service id: %s; delete a collection fo PV: %v", serviceGCReq.ServiceID, err)
	}

	if err := g.clientset.CoreV1().PersistentVolumeClaims(serviceGCReq.TenantID).DeleteCollection(deleteOpts, listOpts); err != nil {
		logrus.Warningf("service id: %s; delete a collection fo PVC: %v", serviceGCReq.ServiceID, err)
	}
}

// DelVolumeDataByVolumeID -
func (g *GarbageCollector) DelVolumeDataByVolumeID(volumeGCReq model.VolumeGCTaskBody) {
	f := func(prefix string) {
		dir := path.Join(prefix, fmt.Sprintf("tenant/%s/service/%s", volumeGCReq.TenantID, volumeGCReq.ServiceID), volumeGCReq.VolumePath)
		logrus.Infof("volume data. delete %s", dir)
		if err := os.RemoveAll(dir); err != nil {
			logrus.Warningf("dir: %s; remove volume data: %v", dir, err)
		}
	}
	f("/grdata")
	f("/grlocaldata")
}

// DelPvPvcByVolumeID -
func (g *GarbageCollector) DelPvPvcByVolumeID(volumeGCReq model.VolumeGCTaskBody) {
	logrus.Infof("volume id: %d; delete PV/PVC.", volumeGCReq.VolumeID)
	listOpts := metav1.ListOptions{
		LabelSelector: fmt.Sprintf("service_id=%s", volumeGCReq.ServiceID),
	}
	pvs, err := g.clientset.CoreV1().PersistentVolumes().List(listOpts)
	if err != nil {
		logrus.Warningf("list pvc: %v", err)
	}
	namePrefix := fmt.Sprintf("manual%d", volumeGCReq.VolumeID)
	for _, pv := range pvs.Items {
		claimRef := pv.Spec.ClaimRef
		if !strings.HasPrefix(claimRef.Name, namePrefix) {
			continue
		}
		if err := g.clientset.CoreV1().PersistentVolumeClaims(volumeGCReq.TenantID).Delete(claimRef.Name, &metav1.DeleteOptions{}); err != nil {
			logrus.Warningf("volume id: %d; delete pvc: %v", volumeGCReq.VolumeID, err)
		}
		if err := g.clientset.CoreV1().PersistentVolumes().Delete(pv.Name, &metav1.DeleteOptions{}); err != nil {
			logrus.Warningf("volume id: %d; delete pv: %v", volumeGCReq.VolumeID, err)
		}
	}
}
